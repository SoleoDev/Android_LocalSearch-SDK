/*
 * SoleoLocalSearchAPI
 *
 * This file was automatically generated for SOLEO by APIMATIC BETA v2.0 on 03/01/2016
 */
package com.soleo.lsapi.controllers;

import java.io.*;
import java.util.*;
import com.fasterxml.jackson.core.type.TypeReference;

import com.soleo.lsapi.http.client.HttpClient;
import com.soleo.lsapi.http.client.HttpContext;
import com.soleo.lsapi.http.request.HttpRequest;
import com.soleo.lsapi.http.response.HttpResponse;
import com.soleo.lsapi.http.response.HttpStringResponse;
import com.soleo.lsapi.http.client.APICallBack;
import com.soleo.lsapi.*;
import com.soleo.lsapi.models.*;

public class BusinessListingsController extends BaseController {
    /**
     * Initialize the base controller using the given http client
     */
    public BusinessListingsController() {
        super();
    }

    /**
     * Initialize the base controller using the given http client
     *
     * @param _client The given http client */
    public BusinessListingsController(HttpClient _client) {
        super(_client);
    }

    /**
     * This is the End Point for the Presented Call Back
     * @param    url    Required parameter: This is a value that is auto generated by the Call back
     * @param callBack  Required parameter: What needs to be done after the Async task is completed
     */
    public void createPresentedAsync(
            final String url,
            final APICallBack<CallBack> callBack
    ) {
        //load all headers for the outgoing API request
        Map<String, String> headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4681282444934260208L;
            {
                put( "user-agent", "SOLEO.SDK.2.0.1" );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest request = clientInstance.post(url, headers, new HashMap<String, Object>());

        int timeout = 7; //seconds
        request.getParameters().put("http.socket.timeout", timeout * 1000);
        request.getParameters().put("http.connection.timeout", timeout * 1000);
        request.getParameters().put("http.connection-manager.timeout", new Long(timeout * 1000));
        request.getParameters().put("http.protocol.head-body-timeout", timeout * 1000);

        //invoke request and get response
        Runnable responseTask = new Runnable() {
            public void run() {
                //make the API call
                clientInstance.executeAsStringAsync(request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext context, HttpResponse response, String query) {
                        try {
                            //Error handling using HTTP status codes
                            int responseCode = response.getStatusCode();
                            if (responseCode == 400)
                                throw new APIException("Bad request (API)", 400, response.getRawBody());

                            else if (responseCode == 403)
                                throw new APIException("Inactive/Unknown Key (Proxy)", 403, response.getRawBody());

                            else if (responseCode == 410)
                                throw new APIException("Gone (API)", 410, response.getRawBody());

                            else if (responseCode == 504)
                                throw new APIException("Gateway Timeout (proxy)", 504, response.getRawBody());

                            else if (responseCode == 500)
                                throw new APIException("The server experienced an internal issue and could not process the API request.", 500, response.getRawBody());

                            else if ((responseCode < 200) || (responseCode > 206)) //[200,206] = HTTP OK
                                throw new APIException("HTTP Response Not OK", responseCode, response.getRawBody());

                            //extract result from the http response
                            CallBack result = APIHelper.deserialize(((HttpStringResponse)response).getBody(),
                                                        new TypeReference<CallBack>(){});

                            //let the caller know of the success
                            callBack.onSuccess(context, result, url);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(context, exception);
                        }
                    }
                    public void onFailure(HttpContext context, Throwable error) {
                        //let the caller know of the failure
                        error.printStackTrace();
                        callBack.onFailure(context, error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(responseTask);
    }

    /**
     * This is the Endpoint for accessing the selected with details call back
     * @param    url   Required parameter: The Jsession ID that is generated by the Call
     * @param callBack this is what needs to be done when the Async task is completed
     */
    public void createSelectWithDetailsAsync(
            final String url,
            final APICallBack<SelectedWithDetailsCall> callBack
    ) {
        //load all headers for the outgoing API request
        Map<String, String> headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4617047096978743313L;
            {
                    put( "user-agent", "SOLEO.SDK.2.0.1" );
        }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest request = clientInstance.post(url, headers, new HashMap<String, Object>());

        int timeout = 7; //seconds
        request.getParameters().put("http.socket.timeout", timeout * 1000);
        request.getParameters().put("http.connection.timeout", timeout * 1000);
        request.getParameters().put("http.connection-manager.timeout", new Long(timeout * 1000));
        request.getParameters().put("http.protocol.head-body-timeout", timeout * 1000);

        //invoke request and get response
        Runnable responseTask = new Runnable() {
            public void run() {
                //make the API call
                clientInstance.executeAsStringAsync(request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext context, HttpResponse response, String query) {
                        try {
                            //Error handling using HTTP status codes
                            int responseCode = response.getStatusCode();
                            if (responseCode == 400)
                                throw new APIException("Bad request (API)", 400, response.getRawBody());

                            else if (responseCode == 403)
                                throw new APIException("Inactive/Unknown Key (Proxy)", 403, response.getRawBody());

                            else if (responseCode == 410)
                                throw new APIException("Gone (API)", 410, response.getRawBody());

                            else if (responseCode == 504)
                                throw new APIException("Gateway Timeout (proxy)", 504, response.getRawBody());

                            else if (responseCode == 500)
                                throw new APIException("The server experienced an internal issue and could not process the API request.", 500, response.getRawBody());

                            else if ((responseCode < 200) || (responseCode > 206)) //[200,206] = HTTP OK
                                throw new APIException("HTTP Response Not OK", responseCode, response.getRawBody());

                            //extract result from the http response
                            SelectedWithDetailsCall result = APIHelper.deserialize(((HttpStringResponse)response).getBody(),
                                                        new TypeReference<SelectedWithDetailsCall>(){});

                            //let the caller know of the success
                            callBack.onSuccess(context, result, url);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(context, exception);
                        }
                    }

                    public void onFailure(HttpContext context, Throwable error) {
                        //let the caller know of the failure
                        callBack.onFailure(context, error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(responseTask);
    }
        
    /**
     * This Endpoint is used to get the Display + Completion number from the API
     * @param    url    Required parameter: The Generated Tracking Number
     * @param callBack  What to do when the async task is completed
     */
    public void getCompletionNumberCallBackAsync(
            final String url,
            final APICallBack<CallCompletionCallback> callBack
    ) {
        //load all headers for the outgoing API request
        Map<String, String> headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 5732556582987682644L;
            {
                    put( "user-agent", "SOLEO.SDK.2.0.1" );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest request = clientInstance.get(url, headers, new HashMap<String, Object>());

        int timeout = 7; //seconds
        request.getParameters().put("http.socket.timeout", timeout * 1000);
        request.getParameters().put("http.connection.timeout", timeout * 1000);
        request.getParameters().put("http.connection-manager.timeout", new Long(timeout * 1000));
        request.getParameters().put("http.protocol.head-body-timeout", timeout * 1000);

        //invoke request and get response
        Runnable responseTask = new Runnable() {
            public void run() {
                //make the API call
                clientInstance.executeAsStringAsync(request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext context, HttpResponse response, String query) {
                        try {
                            //Error handling using HTTP status codes
                            int responseCode = response.getStatusCode();
                            if (responseCode == 400)
                                throw new APIException("Bad request (API)", 400, response.getRawBody());

                            else if (responseCode == 403)
                                throw new APIException("Inactive/Unknown Key (Proxy)", 403, response.getRawBody());

                            else if (responseCode == 410)
                                throw new APIException("Gone (API)", 410, response.getRawBody());

                            else if (responseCode == 504)
                                throw new APIException("Gateway Timeout (proxy)", 504, response.getRawBody());

                            else if (responseCode == 500)
                                throw new APIException("The server experienced an internal issue and could not process the API request.", 500, response.getRawBody());

                            else if ((responseCode < 200) || (responseCode > 206)) //[200,206] = HTTP OK
                                throw new APIException("HTTP Response Not OK", responseCode, response.getRawBody());

                            //extract result from the http response
                            CallCompletionCallback result = APIHelper.deserialize(((HttpStringResponse)response).getBody(),
                                                        new TypeReference<CallCompletionCallback>(){});

                            //let the caller know of the success
                            callBack.onSuccess(context, result, url);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(context, exception);
                        }
                    }
                    public void onFailure(HttpContext context, Throwable error) {
                        //let the caller know of the failure
                        callBack.onFailure(context, error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(responseTask);
    }
        
    /**
     * Endpoint used when one of the two provided numbers was called
     * @param    url    Required parameter: The generated snip, takes ether the Completion Snip or the Displayed Snip
     * @param callBack  What to do when the Async task is completed
     * */
    public void getCalledNumberAsync(
            final String url,
            final APICallBack<String> callBack
    ) {
        //load all headers for the outgoing API request
        Map<String, String> headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4887939388053679393L;
            {

                put( "user-agent", "SOLEO.SDK.2.0.1" );

            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest request = clientInstance.get(url, headers, new HashMap<String, Object>());

        int timeout = 7; //seconds
        request.getParameters().put("http.socket.timeout", timeout * 1000);
        request.getParameters().put("http.connection.timeout", timeout * 1000);
        request.getParameters().put("http.connection-manager.timeout", new Long(timeout * 1000));
        request.getParameters().put("http.protocol.head-body-timeout", timeout * 1000);

        //invoke request and get response
        Runnable responseTask = new Runnable() {
            public void run() {
                //make the API call
                clientInstance.executeAsStringAsync(request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext context, HttpResponse response , String query) {
                        try {
                            //Error handling using HTTP status codes
                            int responseCode = response.getStatusCode();
                            if (responseCode == 400)
                                throw new APIException("Bad request (API)", 400, response.getRawBody());

                            else if (responseCode == 403)
                                throw new APIException("Inactive/Unknown Key (Proxy)", 403, response.getRawBody());

                            else if (responseCode == 410)
                                throw new APIException("Gone (API)", 410, response.getRawBody());

                            else if (responseCode == 504)
                                throw new APIException("Gateway Timeout (proxy)", 504, response.getRawBody());

                            else if (responseCode == 500)
                                throw new APIException("The server experienced an internal issue and could not process the API request.", 500, response.getRawBody());

                            else if ((responseCode < 200) || (responseCode > 206)) //[200,206] = HTTP OK
                                throw new APIException("HTTP Response Not OK", responseCode, response.getRawBody());

                            //extract result from the http response
                            String result = ((HttpStringResponse)response).getBody();
                            //let the caller know of the success
                            callBack.onSuccess(context, result, url);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(context, error);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(context, exception);
                        }
                    }
                    public void onFailure(HttpContext context, Throwable error) {
                        //let the caller know of the failure
                        callBack.onFailure(context, error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(responseTask);
    }
        
    /**
     * The Businesses endpoint searches business listings, returning both organic and sponsored business listings (ads) in the same result along with callbacks for monetizeable events.  Searches run against the Soleo Intent Engine, returning relevant search results with highly-accurate data based on geographic location (geocode, city/state, or postal code) and business category or keyword.
     * @param    aPIKey    Required parameter: API Key
     * @param    accept    Optional parameter: Identifies the requested API version and response format. (Acceptable values are: "application/vnd.api.soleo.com-v1+json", "application/vnd.api.soleo.com-v1+xml")
     * @param    aNI    Optional parameter: The end user's phone number.
     * @param    category    Optional parameter: The category that defines (or relates to) the commercial offering of a business.  If Category and Keyword parameters are both provided, the Category parameter takes precedence.  One of Keyword, Category, or Name parameters is required.
     * @param    city    Optional parameter: The name of the city to use as a search point.  If used, you must also provide a state to form a complete city and state pair.
     * @param    iPAddress    Optional parameter: The IP address of the end user.
     * @param    keyword    Optional parameter: A term to search against business names and categories.  One of Keyword, Category, or Name parameters is required.
     * @param    freeformquery    Optional parameter: A term to  analise with our Natural Language Processing and use to search against business names and categories.  One of Keyword, Category, Name or FreeFormQuery parameters is required. FreeFromQuery will take precedence over Keyword, Category and Name.
     * @param    latitude    Optional parameter: The latitude of the search point.  Valid value range [0.000000, 90.000000].  If used, you must also provide a longitude to form a complete geocode for the search point.  Search points are limited to the continental United States, Alaska, and Hawaii.
     * @param    longitude    Optional parameter: The longitude of the search point.  Valid value range [-180.000000, 0.000000].  If used, you must also provide a latitude to form a complete geocode for the search point.  Search points are limited to the continental United States, Alaska, and Hawaii.
     * @param    name    Optional parameter: The name of a business.  If Name and Keyword parameters are both provided, the Name parameter takes precedence.  One of Keyword, Category, or Name parameters is required.
     * @param    openOnly    Optional parameter: If 'yes', only returns businesses that are known to not be closed at the current time. (Acceptable values are: "", "yes", "no")
     * @param    postalCode    Optional parameter: The postal code of a location.  Valid entries are 5-digit postal codes (ex. '14450'), 9-digit postal codes with a dash between the fifth and sixth digits (ex. '14450-4222'), or 9-digit postal codes with no dash (ex. '144504222').
     * @param    radius    Optional parameter: The radius (in miles) which forms a circular fence around the search point.  Valid value range [0.01, 999.99].  If used, you must also provide a search point with a latitude and longitude (geocode) pair.
     * @param    referenceID    Optional parameter: A unique string or identifier, provided by the developer, used to represent the API transaction.
     * @param    sort    Optional parameter: The sort preference for the results. Valid values are 'value' (sort results by the estimated value, highest to lowest, where estimated value is a function of the monetizable amount in combination with the result relevancy and monetization probability), 'distance' (sort results by proximity to the search point, shortest to furthest), and 'value_distance' (sort results by the estimated value, highest to lowest, then by proximity to the search point, shortest to furthest). (Acceptable values are: "", "value", "distance", "value_distance")
     * @param    sourceID    Optional parameter: A unique string or identifier, provided by the developer, which represents the end user of the API transaction.
     * @param    state    Optional parameter: The name of the state to use as a search point.  If used, you must also provide a city to form a complete city and state pair. (Acceptable values are: "", "AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "DC", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY", "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "WA", "WV", "WS", "WY")
     * @param    type    Optional parameter: Limits the type of businesses that are searched and returned.  Valid values are 'Organic' (to search and return organic business listings), 'Presented' (to search and return sponsored business listings which have impression revenue opportunities), 'Selected' (to search and return sponsored business listings which have selection opportunities), and 'Called' (to search and return sponsored business listings which have pay-per-call revenue opportunities).  Multiple values can be provided as a comma-delimited list (ex. type=Presented,Selected,Called).
     * @param    maxSponsoredCount    Optional parameter: Request a number of listing of type Sponsored.
     * @param    maxOrganicsCount    Optional parameter: Request a number of listing of type organic.
     * @param    userAgent    Optional parameter: This header provides information about the user agent originating the request.
	 * @return	Returns the Response response from the API call*/
    public void getBusinessesAsync(
            final String aPIKey,
            final String accept,
            final String aNI,
            final String category,
            final String city,
            final String iPAddress,
            final String keyword,
            final String freeformquery,
            final String latitude,
            final String longitude,
            final String name,
            final String openOnly,
            final String postalCode,
            final String radius,
            final String referenceID,
            final String sort,
            final String sourceID,
            final String state,
            final String type,
            final String userAgent,
            final String maxSponsoredCount,
            final String maxOrganicsCount,
            final APICallBack<Response> callBack
    ) {

        String baseUri = Configuration.baseUri;

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri);
        queryBuilder.append("/businesses/?");

        //process query parameters
        APIHelper.appendUrlWithQueryParameters(queryBuilder, new HashMap<String, Object>() {
            private static final long serialVersionUID = 5539567495359628106L;
            {
                    put( "APIKey", aPIKey );
                    put( "ANI", aNI );
                    put( "Category", category );
                    put( "City", city );
                    put( "IPAddress", iPAddress );
                    put( "Keyword", keyword );
                    put( "FreeFormQuery" , freeformquery);
                    put( "Latitude", latitude );
                    put( "Longitude", longitude );
                    put( "Name", name );
                    put( "OpenOnly", (null != openOnly) ? openOnly : "No" );
                    put( "PostalCode", postalCode );
                    put( "Radius", (null != radius) ? radius : "10" );
                    put( "ReferenceID", referenceID );
                    put( "Sort", (null != sort) ? sort : "distance" );
                    put( "SourceID", sourceID );
                    put( "State", state );
                    put( "Type", (null != type) ? type : "organic,presented,selected,called" );
                    put( "MaxSponsoredCount", (null != maxSponsoredCount) ? maxSponsoredCount : "3");
                    put( "MaxOrganicCount", (null != maxOrganicsCount) ? maxOrganicsCount : "7");
                    put( "APIKey", Configuration.getAPIKey() );
            }});
        //validate and preprocess url
        final String queryUrl = APIHelper.cleanUrl(queryBuilder);

        //load all headers for the outgoing API request
        Map<String, String> headers = new HashMap<String, String>() {
            private static final long serialVersionUID = 4632376119592519824L;
            {
//                  put( "user-agent", "SOLEO.SDK.2.0.1" );
                    put( "accept", accept );
                    put( "user-Agent", userAgent );
            }
        };

        //prepare and invoke the API call request to fetch the response
        final HttpRequest request = clientInstance.get(queryUrl, headers, new HashMap<String, Object>());

        int timeout = 7; //seconds
        request.getParameters().put("http.socket.timeout", timeout * 1000);
        request.getParameters().put("http.connection.timeout", timeout * 1000);
        request.getParameters().put("http.connection-manager.timeout", new Long(timeout * 1000));
        request.getParameters().put("http.protocol.head-body-timeout", timeout * 1000);

        //invoke request and get response
        Runnable responseTask = new Runnable() {
            public void run() {
                //make the API call
                clientInstance.executeAsStringAsync(request, new APICallBack<HttpResponse>() {
                    public void onSuccess(HttpContext context, HttpResponse response, String query) {
                        try {
                            //Error handling using HTTP status codes
                            int responseCode = response.getStatusCode();
                            if (responseCode == 400)
                                throw new APIException("Bad Request (API)", 400, response.getRawBody());

                            else if (responseCode == 410)
                                throw new APIException("Gone (API)", 410, response.getRawBody());

                            else if (responseCode == 403)
                                throw new APIException("Inactive/Unknown Key (Proxy)", 403, response.getRawBody());

                            else if (responseCode == 500)
                                throw new APIException("Internal Server Error (API)", 500, response.getRawBody());

                            else if (responseCode == 504)
                                throw new APIException("Gateway Timeout (Proxy)", 504, response.getRawBody());

                            else if (responseCode == 404)
                                throw new APIException("The API request was made to an invalid resource or endpoint.", 404, response.getRawBody());

                            else if (responseCode == 405)
                                throw new APIException("The initial search for businesses was made using an HTTP method other than GET.", 405, response.getRawBody());

                            else if (responseCode == 406)
                                throw new APIException("The API request contains an invalid Accept header.", 406, response.getRawBody());

                            else if ((responseCode < 200) || (responseCode > 206)) //[200,206] = HTTP OK
                                throw new APIException("HTTP Response Not OK", responseCode, response.getRawBody());

                            //extract result from the http response
                            Response result = APIHelper.deserialize(((HttpStringResponse)response).getBody(),
                                                        new TypeReference<Response>(){});

                            //let the caller know of the success
                            callBack.onSuccess(context, result, queryUrl);
                        } catch (APIException error) {
                            //let the caller know of the error
                            callBack.onFailure(context, error);
                        } catch (IOException ioException) {
                            //let the caller know of the caught IO Exception
                            callBack.onFailure(context, ioException);
                        } catch (Exception exception) {
                            //let the caller know of the caught Exception
                            callBack.onFailure(context, exception);
                        }
                    }
                    public void onFailure(HttpContext context, Throwable error) {
                        //let the caller know of the failure
                        callBack.onFailure(context, error);
                    }
                });
            }
        };

        //execute async using thread pool
        APIHelper.getScheduler().execute(responseTask);
    }
        
}